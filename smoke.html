<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
	<style>
		/* We want our scene to span the entire window */
		body { margin: 0; }
	</style>
</heda>
<body>

  <script id="diffuseShader" type="shader-code">

		uniform vec2 res; // Screen resolution
		uniform sampler2D densityBufferTexture;
    uniform sampler2D previousDensity;

		uniform vec3 smokeSource; // (x_pos, y_pos, "power")
    uniform float radius;
    uniform float sourceRedWeight;

		void main() {
      // Fragcoord and res are both in width x height --> have to convert to 0->1.0 range
      // Which is the range 'pixel' is within
      vec2 pixel = gl_FragCoord.xy / res.xy;

      // gl_FragColor is our "return value" for thie pixel
      gl_FragColor = texture2D(densityBufferTexture, pixel);

      //////////// SOURCE  //////////////////

      // If within the specified radius, add smoke here
      float dist = distance(smokeSource.xy, gl_FragCoord.xy);
      float sourceSmokeAmt = smokeSource.z * max(radius - dist, 0.0); // don't go outside radius
      float finalSourceRed = sourceSmokeAmt;
      float finalSourceGreen = sourceSmokeAmt;
      float finalSourceBlue = sourceSmokeAmt;
      gl_FragColor.r += sourceRedWeight * finalSourceRed;
      gl_FragColor.g += finalSourceGreen;
      gl_FragColor.b += finalSourceBlue;
      // gl_FragColor.r = gl_FragColor.r * sourceRedWeight;

      // Additionally, move smoke over from neighboring pixels and vice versa
      float xPixelSize = 1.0 / res.x;
      float yPixelSize = 1.0 / res.y;

      //////////// DIFFUSE  //////////////////

      vec4 rightSmoke = texture2D(densityBufferTexture, vec2(pixel.x + xPixelSize, pixel.y));
      vec4 leftSmoke = texture2D(densityBufferTexture, vec2(pixel.x - xPixelSize, pixel.y));
      vec4 upSmoke = texture2D(densityBufferTexture, vec2(pixel.x, pixel.y + yPixelSize));
      vec4 downSmoke = texture2D(densityBufferTexture, vec2(pixel.x, pixel.y - yPixelSize));

      float FPS_FACTOR = 1.0 / 60.0;
      float UPDATE_FACTOR = 7.4;

      // float diffuseSmoke = UPDATE_FACTOR * FPS_FACTOR * (leftSmoke.r + rightSmoke.r + downSmoke.r * 3.0 + upSmoke.r - 6.0 * gl_FragColor.r);
      float diffuseSmoke = UPDATE_FACTOR * FPS_FACTOR * (leftSmoke.g + rightSmoke.g + downSmoke.g + upSmoke.g - 4.0 * gl_FragColor.g);

      // Adjust new smoke values because of bad texel resolution
      float minimumNewSmoke = 0.003;
  		if (diffuseSmoke < 0.0 && diffuseSmoke >= -minimumNewSmoke) {
        diffuseSmoke = -minimumNewSmoke;
      }

      // TODO: Have operations for all three channels

      gl_FragColor.rgb += diffuseSmoke;
		 }
	</script>


  <script id="advectShader" type="shader-code">
		uniform vec2 res; // Screen resolution
		uniform sampler2D densityBufferTexture;
    // uniform sampler2D previousDensity;
		// uniform vec3 smokeSource; // (x_pos, y_pos, "power")
    // uniform float radius;

		void main() {
      float FPS_FACTOR = 1.0 / 60.0;

      vec2 pixel = gl_FragCoord.xy / res.xy;
      // gl_FragColor = texture2D(densityBufferTexture, pixel);

      // gl_FragColor = vec4(0.0,0.0,0.0,1.0);

      // float vY = max(min(.5 * sin(6 * pixel.y), 0.9), 0.1);
      // float vY = pixel.y;
      // float vY = sin(0.7);
      // float vY = 1.0;
      float dY = 0.5*(1.0-pixel.y); //0.2 * cos(32.0  * pixel.y);
      float prevY = pixel.y - FPS_FACTOR * dY;
      float dX = 0.4*(1.0-pixel.x);//0.1 * sin(32.0 * pixel.x);
      float prevX = pixel.x - FPS_FACTOR * dX;

      vec4 prevSmoke = texture2D(densityBufferTexture, vec2(prevX, prevY));
      gl_FragColor.xyz = prevSmoke.xyz;

      // vec4 prevYSmoke = texture2D(densityBufferTexture, vec2(pixel.x, prevY));
      // gl_FragColor.xyz += prevYSmoke.xyz;


      // vec4 prevXSmoke = texture2D(densityBufferTexture, vec2(prevX, pixel.y));
      // gl_FragColor.xyz += prevXSmoke.xyz;


		 }
	</script>

  <script>
    // Initialize three.js scene, camera and renderer
		var camera;
		var renderer;

		// Set up a vanilla scene
		finalScene = new THREE.Scene();

		var width = window.innerWidth;
		var height = window.innerHeight;

		camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 1000);
		camera.position.z = 2; // Put camera in front of everything

		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

    // Plane holding all of the graphics
    var canvas;

    // Buffer variables: Source and Diffusion
    var textureA;
		var bufferMaterial;
		var bufferObject;
    var bufferScene;

    // Second buffer: Velocity field
    var textureB;
    var bufferMaterial2;
		var bufferObject2;
    var bufferScene2;

    // Actual, displayed scene variables
    var textureC;
		var finalMaterial;
		var finalObject;
    var finalScene;

		function buffer_texture_setup(){
			canvas = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight);

			// Create 2 buffer textures which will eventually hold our buffer scene, taking turns
      // TextureB is always the one that's on the scene
      // TextureA is always the one that's in the bufferMaterial/Scene
			textureA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
			textureB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter} );
      textureC = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter} );


      //////// DIFFUSION ////////

      // Create buffer scene, which will hold the shader material (bufferMaterial)
			bufferScene = new THREE.Scene();
      // Contains the shader and defines uniforms, first passing textureA through
      bufferMaterial = new THREE.ShaderMaterial( {
				uniforms: {
				 densityBufferTexture: {
           type: "t", value: textureA
         },
         previousDensity: {
            type: "t", value: textureA
         },
				 res: { // Screen resolution
           type: 'v2',
           value: new THREE.Vector2(window.innerWidth, window.innerHeight)
         },
				 smokeSource: { // Represents coordinates / radius / power of an ongoing smoke source
           type: 'v3',
           value: new THREE.Vector3(0,0,0)
         },
         radius: { // Refer to this for types: https://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders-part-2--cms-24111
          type: 'f',
          value: 12.0
        },
        sourceRedWeight: { // Randomized: how much we want to "weight" red in the smoke source for a semi-randominzed color
          type: 'f',
          value: 1.0
        }
				},
				fragmentShader: document.getElementById('diffuseShader').innerHTML
			} );
			bufferObject = new THREE.Mesh(canvas, bufferMaterial); // create object containing Shader info / screen
			bufferScene.add(bufferObject); // add this info to buffer scene


      // Create buffer scene, which will hold the shader material (bufferMaterial)
			bufferScene2 = new THREE.Scene();
      // Contains the shader and defines uniforms, first passing textureA through
      bufferMaterial2 = new THREE.ShaderMaterial( {
				uniforms: {
				 densityBufferTexture: {
           type: "t", value: textureB
         },
         res: { // Screen resolution
           type: 'v2',
           value: new THREE.Vector2(window.innerWidth, window.innerHeight)
         }
       },
			fragmentShader: document.getElementById('advectShader').innerHTML
      } );
			bufferObject2 = new THREE.Mesh(canvas, bufferMaterial2); // create object containing Shader info / screen
			bufferScene2.add(bufferObject2); // add this info to buffer scene

      // Do the same thing for the actual scene/material/object: definitions are parallel to the buffer ones
      // Draw textureB to material --> mesh --> actual scene
			finalMaterial =  new THREE.MeshBasicMaterial({map: textureC}); // Contains TextureB
			finalObject = new THREE.Mesh(canvas, finalMaterial); // Contains the general plane (the entire screen) and textureB
			finalScene.add(finalObject); // Add to real (non-buffered) scene
		}
		buffer_texture_setup();


    function generateSmokeAt(x, y, z, radius, red) {
      bufferMaterial.uniforms.smokeSource.value.x = x;
		  bufferMaterial.uniforms.smokeSource.value.y = window.innerHeight - y;
      bufferMaterial.uniforms.smokeSource.value.z = z;

      bufferMaterial.uniforms.radius.value = radius;

      bufferMaterial.uniforms.sourceRedWeight.value = red;
    }

    var BETWEEN_SMOKE_TIME = 500; // 500 ms before each puff of smoke is generated
    var GEN_SMOKE_TIME = 100; // Generate smoke from a source for 100 ms
    function resumeSmoke() {
      // console.log("Resuming smoke...")

      width = window.innerWidth
      height = window.innerHeight

      var random_x = (Math.random() - 0.5) * (height / 3);
      var random_y = (Math.random() - 0.5) * (height / 2); // From 2nd->3rd quarter
      var radius = (Math.random()*4 + 1.0) * 10; // Varies from 10->50
      var sourceRedWeight = Math.random();

      console.log(sourceRedWeight)

      generateSmokeAt(width / 2 + random_x, height / 2 + random_y, 0.1, radius, sourceRedWeight);

      // if (!requestStop) {
      setTimeout(pauseSmoke, GEN_SMOKE_TIME);
      // }
    }
    function pauseSmoke() {
      // console.log("Pausing smoke...")
      bufferMaterial.uniforms.smokeSource.value.z = 0;
      setTimeout(resumeSmoke, BETWEEN_SMOKE_TIME);
    }
    resumeSmoke()

		function render() {
		  requestAnimationFrame(render); // Set this function as the callback for the future

      // Steps according to https://gamedevelopment.tutsplus.com/tutorials/quick-tip-how-to-render-to-a-texture-in-threejs--cms-25686
        // 1. Create a scene to hold your objects.
        // 2. Create a texture to store what you render
        // 3. Render your scene onto your texture


      // textureA -> source/diffuse shader -> textureB -> velocity shader -> textureC -> Screen

       // Assume that textureA thru the shader (thru bufferMaterial)
		   // Now, move bufferscene objects (result of passing A through shader) --> textureB
		  renderer.render(bufferScene, camera, textureB, true); // This is the line that maintains the pairing between txtA and txtB

      //////// NEW //////// !!!
      renderer.render(bufferScene2, camera, textureC, true)

      // bufferMaterial2.uniforms.densityBufferTexture.value = textureB;
      // renderer.render(bufferScene2, camera, textureB, true);

      // This line applies to any WebGL project; draw to screen
      // Render texture C to the scene (through finalObject since we just swapped it)
		  renderer.render(finalScene, camera );

		  var swap = textureA;
		  textureA = textureC;
		  textureC = swap;

		  bufferMaterial.uniforms.densityBufferTexture.value = textureA; // Swap the buffer's texture to textureA
      finalObject.material.map = textureC; // "finalObject" is an object that has been added to the scene
		}
		render();
  </script>
</body>
</html>
